// 퀵정렬
// 특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까? 
//기준 값이 존재: 피벗이라고 한다. 
//특정한 피벗을 통해 왼쪽과 오른쪽을 나눈다. 
// 빠른 알고리즘
// 분할 정복 알고리즘
// 배열의 원소들을 나누어서 계산을 한다
// 시간 복잡도가 O(N*logN) // 사실상 거의 상수라고 할 수 있다.

//순서 
//가장 앞을 피벗값으로 설정
// 왼쪽에서 오른쪽, 오른쪽에서 왼쪽으로 이동
// 왼쪽에서 오른쪽으로 이동하면서 가장 앞보다 큰 값을 선택한다.
// 오른쪽으로부터는 앞보다 작은 값을 선택한다. 
//거기서 큰 값과 작은 값을 바꾸어준다.
//반복
// 그러다가 작은 값의 인덱스가 큰 값의 인덱스보다 작을 경우 ==> 엇갈렸다고 표현
// ==> 엇갈렸을 때는 맨 앞값과 작은 값을 바꾸어준다.
// 바꾼 값 기준으로 왼쪽은 정렬이 되어 있게 된다. 
//피벗을 바꾸고
//왼쪽과 오른쪽을 피벗을 따로 수행?
//왼쪽부터 큰 값을 찾는다 
//오른쪽부터 작은 값이 없으면? 엇갈린 것이기 때문에 1과 자기 자신을 또 바꾼다
//그다음 또 2부터 피벗을 수행
//그다음 아까 피벗 수행 안한 큰 값부터 피벗을 수행 
//엇갈리면 바꾸어주고 기존 피벗값 기준으로 왼쪽 은 작은 값 큰 값은 오른쪽에 있게 된다.
//왼쪽 퀵정렬, 오른쪽 퀵 정렬
//한번 정렬을 수행했을 때 왼쪽과 오른쪽이 나누어지게 된다. 
//쪼갠다음 쪼갠 것을 정렬하고 합치기 때문에 분할 정복 ==> 빠르다. 
// 항상  O(N*logN)를 보장하는 것은 아니지만 대체로 그만큼 빠르다.
//백만개 정도는 어렵지 않게 처리 가능
//재귀 함수를 사용하는 경우가 많다. 
//퀵 정렬의 최악 시간 복잡도는 O(N^2)이다. 

#include<stdio.h>

int number = 10;
int data[10] = {1,10,5,8,7,6,4,3,2,9};
void quickSort(int *data, int start, int end){//start는 정렬 수행 첫번째, end는 마지막 
	if(start >= end){ //start가 end보다 큰 경우는 원소가 1개인 경우이다. 
		return; //그 경우는 바로 return 
	}
	
	//피벗값을 잡아준다.
	int key = start; //피벗값은 첫번째 원소
	int i = start + 1; //i는 왼쪽부터 하나씩 큰 값을 찾을 때 그 인덱스를 의미, 키값 바로 오른쪽부터 이동
	int j = end; //마지막값 -> 왼쪽으로 이동//오른쪽 출발 지점 
	int temp;
	
	while(i <= j) { //엇갈릴 때까지 반복 
		while(data[i] <= data[key]){ //i가 키값보다 작다면 //키 값보다 큰 값을 만날 때까지 오른쪽으로 이동 
			i++; //i를 한칸씩 오른쪽으로 이동 
		}//왼쪽과 키 값을 교체해주기 때문에 굳이 여기에는 안 걸어주어도 된다?
		while(data[j] >= data[key] && j>start){//키 값보다 작은 값을 만날 때까지 반복 
			j--;
		}
		if(i>j){ //엇갈렸다면 
			temp = data[j];
			data[j] = data[key];
			data[key] = temp;
		} else{ //엇갈리지 않았다면 //j와 i를 바꾸어주면 된다. 
			temp = data[j];
			data[j] = data[i];
			data[i] = temp;
		}
	}
	
	//엇갈렸을 경우 //왼쪽 오른쪽 퀵정렬 
	quickSort(data, start, j-1);
	quickSort(data, j+1, end);
}

int main(void) {
	quickSort(data, 0 ,number-1);
	for(int i=0; i<number; i++){
		printf("%d\n", data[i]);
	}
} 
 
